This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: xmake.lua, src, game
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
game/
  .gitignore
  initEngine.json
  main.cpp
  one.glb
  player.hpp
  xmake.lua
src/
  Audio/
    Audio.cpp
    Audio.hpp
  Collider/
    Collider2D/
      Collider2D.cpp
      Collider2D.hpp
  ECS/
    Components/
      Audio/
        Audio.cpp
        Audio.hpp
      Camera/
        Camera2D/
          Camera2D.cpp
          Camera2D.hpp
        Camera3D/
          Camera3D.cpp
          Camera3D.hpp
      Collider/
        Collider2D/
          Collider2D.cpp
          Collider2D.hpp
      Mesh/
        Mesh.cpp
        Mesh.hpp
      Physic/
        Physic2D/
          Physic2D.cpp
          Physic2D.hpp
          PhysicComponent2
      Sprite/
        Sprite.cpp
        Sprite.hpp
      Transform/
        Transform2D/
          Transform.cpp
          Transform.hpp
        Transform3D/
          Transform3D.cpp
          Transform3D.hpp
      Component.hpp
    Objects/
      Entity.cpp
      Entity.hpp
      Entity.inl
    Systems/
      System.hpp
  engine/
    Engine.cpp
    Engine.hpp
    Engine.inl
  graphics/
    Render2D/
      Render2D.cpp
      Render2D.hpp
    Render3D/
      Render3D.cpp
      Render3D.hpp
    Terminal.cpp
    Terminal.hpp
  Logger/
    Logger.cpp
    Logger.hpp
  Physic/
    Physic2D/
      Physic.cpp
      Physic.hpp
  Scene/
    Scene.cpp
    Scene.hpp
    Scene.inl
  UI/
    UI.cpp
    UI.hpp
  Var/
    Var.cpp
    Var.hpp
  rica.hpp
  xmake.lua
xmake.lua
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="game/player.hpp">
// Файл: game/player.hpp

#pragma once

#include "../src/rica.hpp"
#include "raylib.h"
// Включаем только 3D компоненты
#include "../src/ECS/Components/Mesh/Mesh.hpp"
#include "../src/ECS/Components/Transform/Transform3D/Transform3D.hpp" 
// Удалены: Sprite, Transform2D, Camera2D, Audio
#include <iostream>
#include <memory> 

class Player : public Entity {
private:
    float speed = 5.0f; // Адаптированная скорость для 3D
    
    // Используются только 3D компоненты
    std::shared_ptr<MeshComponent> mesh;
    std::shared_ptr<Transform3DComponent> trans; 
    
    // Удалены isAudioPlaying, transformComp, audioComp

public:
    Player() {
        mesh = std::make_shared<MeshComponent>();
        trans = std::make_shared<Transform3DComponent>();

        this->addComponent(mesh);
        this->addComponent(trans);

        mesh->loadMesh("one.glb"); 

        // Transform3DComponent ожидает Vector3
        trans->setPosition({10.0f, 0.0f, 10.0f});
        trans->setScale({0.5f, 0.5f, 0.5f}); 
        trans->setRotation({0.0f, 0.0f, 0.0f});
    }

    void update(float deltaTime) {
        if (!trans) return; 
        
        Vector3 delta = {0.0f, 0.0f, 0.0f};
        
        // 3D-движение: Z (вперед/назад), X (влево/вправо)
        if(IsKeyDown(KEY_W)) delta.z -= speed * deltaTime; 
        if(IsKeyDown(KEY_S)) delta.z += speed * deltaTime; 
        if(IsKeyDown(KEY_A)) delta.x -= speed * deltaTime; 
        if(IsKeyDown(KEY_D)) delta.x += speed * deltaTime; 
        
        Vector3 currentPos = trans->getPosition();
        
        trans->setPosition({
            currentPos.x + delta.x,
            currentPos.y + delta.y,
            currentPos.z + delta.z
        });
        
        // Удалена вся устаревшая 2D- и аудио-логика
    }
    
};
</file>

<file path="src/ECS/Components/Camera/Camera3D/Camera3D.hpp">
#pragma once
#include "../../Component.hpp"
#include <raylib.h>
#include <raymath.h>

class Camera3DComponent : public Component {
public:
  Camera3DComponent() = default;

  Camera3DComponent(Vector3 offset, float fovy = 1.0f, bool isActive = true)
      : offset(offset), fovy(fovy), isActive(isActive) {
  }

  Camera3D getCamera3D() const {
    Camera3D cam;
    cam.position=Vector3Add(target, offset);
    cam.fovy=fovy;
    cam.target=target;
    cam.projection=CAMERA_PERSPECTIVE;
    cam.up=Vector3{0.0f, 1.0f, 0.0f};

    return cam;
  }

  void followTarget(Vector3 position) {
    target = position;
  }

  void smoothFollow(Vector3 position, float speed) {
    target.x += (position.x - target.x) * speed;
    target.y += (position.y - target.y) * speed;
  }

  void setTarget(Vector3 target) {
    this->target = target;
  }
  void setOffset(Vector3 offset) {
    this->offset = offset;
  }
  void setRotation(float rotation) {
    this->rotation = rotation;
  }
  void setFovy(float fovy) {
    this->fovy = fovy;
  }
  void setActive(bool isActive) {
    this->isActive = isActive;
  }

  // Getters
  Vector3 getTarget() const {
    return target;
  }
  Vector3 getOffset() const {
    return offset;
  }
  float getRotation() const {
    return rotation;
  }
  float getFovy() const {
    return fovy;
  }
  bool isActiveCamera() const {
    return isActive;
  }

private:
Vector3 target{0.0f, 0.0f, 0.0f};
  Vector3 offset{0.0f, 5.0f, 5.0f}; 
  float rotation = 0.0f; 
  float fovy = 75.0f;
  bool isActive = false;
};
</file>

<file path="src/ECS/Components/Collider/Collider2D/Collider2D.cpp">
#include "Collider2D.hpp"
</file>

<file path="src/ECS/Components/Collider/Collider2D/Collider2D.hpp">
#pragma once
#include "../../../../Logger/Logger.hpp"
#include "../../Component.hpp"
#include <raymath.h>

class Collider2DComponent : public Component {
public:
  Collider2DComponent(Vector2 position, int width, int height, bool isTrigger) {
    this->isTrigger = isTrigger;
    this->position.x = position.x;
    this->position.y = position.y;
    this->width = width;
    this->height = height;
  }

  void setTrigger(bool isTrigger) {
    this->isTrigger = isTrigger;
  }
  void setWidth(int width) {
    this->width = width;
  }
  void setHeight(int height) {
    this->height = height;
  }

  bool getTrigger() {
    return isTrigger;
  }
  Vector2 getPosition() {
    return position;
  }
  int getWidth() {
    return width;
  }
  int getHeight() {
    return height;
  }

  friend class Collider2DSystem;

private:
  bool isTrigger = false;
  Vector2 position;
  int width, height;

  void setX(int x) {
    position.x = x;
  }
  void setY(int y) {
    position.y = y;
  }
};
</file>

<file path="src/ECS/Components/Mesh/Mesh.hpp">
#pragma once
#include "../Component.hpp"
#include <raylib.h>
#include <raymath.h>
#include "../../../Logger/Logger.hpp"
#include "../../../rica.hpp"

class MeshComponent : public Component {
public:
    MeshComponent() = default;

    ~MeshComponent() override {
        if (loaded) {
            UnloadModel(model);
        }
    }

    // Загружаем модель целиком (правильно для GLTF)
    void loadMesh(const char *path) {
        model = LoadModel(path);

        if (model.meshCount == 0) {
            logger.addLog(LogLevel::ERROR, basePath,
                TextFormat("Failed to load mesh: empty meshCount from %s", path),
                "logRica.txt");
            logger.addLog(LogLevel::ERROR, basePath,
                TextFormat("Failed to load mesh: empty meshCount from %s", path));
            return;
        }

        loaded = true;
    }

    // Установить глобальный цвет модели
    void setColor(Color newColor) {
        color = newColor;
    }

    Color getColor() const {
        return color;
    }

    Model& getModel() {
        return model;
    }

    bool isLoaded() const {
        return loaded;
    }

private:
    Model model = { 0 };
    Color color = WHITE;
    bool loaded = false;
};
</file>

<file path="src/ECS/Components/Transform/Transform2D/Transform.cpp">
#include "Transform.hpp"
</file>

<file path="src/ECS/Components/Transform/Transform2D/Transform.hpp">
#pragma once
#include "../../../../rica.hpp"
#include "../../Component.hpp"
#include <cmath>

class TransformComponent : public Component {
public:
  // Конструктор по умолчанию
  TransformComponent() 
    : position({0.0f, 0.0f}), rotation(0.0f), scale(1.0f), width(0.0f), height(0.0f) {}
    
  // --- Старый метод set (Оставим для удобства) ---
  void set(Vector2 position, float rotation, float scale, float width,
           float height) {
    this->position = position;
    this->rotation = rotation;
    this->scale = scale;
    this->width = width;  
    this->height = height; 
  }

  const Vector2& getPosition() const {
    return position;
  }

  float getRotation() const {
    return rotation;
  }

  float getScale() const {
    return scale;
  }
  
  float getWidth() const {
    return width;
  }

  float getHeight() const {
    return height;
  }

  float getScaledWidth() const {
      return width * scale;
  }
  
  float getScaledHeight() const {
      return height * scale;
  }

  Rectangle getDest() const {
    float scaledWidth = getScaledWidth();
    float scaledHeight = getScaledHeight();

    return {position.x - scaledWidth / 2.0f, position.y - scaledHeight / 2.0f,
            scaledWidth, scaledHeight};
  }

  Vector2 getOrigin() const {
    return {
        getScaledWidth() / 2.0f, 
        getScaledHeight() / 2.0f 
    };
  }



  void setPosition(const Vector2& pos) {
    this->position = pos;
  }
  
  void setPosition(float x, float y) {
    this->position.x = x;
    this->position.y = y;
  }

  void setRotation(float rotation) {
    this->rotation = rotation;
  }

  void setScale(float scale) {
    this->scale = scale;
  }

  void setWidth(float width) {
    this->width = width;
  }

  void setHeight(float height) {
    this->height = height;
  }

private:
  Vector2 position;
  float rotation;
  float scale;
  float width;
  float height;
};
</file>

<file path="src/ECS/Components/Transform/Transform3D/Transform3D.hpp">
#pragma once
#include "../../../../rica.hpp"
#include "../../Component.hpp"
#include "raymath.h"

class Transform3DComponent : public Component {
public:
    Transform3DComponent(
        Vector3 position = {0.0f, 0.0f, 0.0f},
        Vector3 rotationAngles = {0.0f, 0.0f, 0.0f},
        Vector3 scale = {1.0f, 1.0f, 1.0f}
    )
        : position(position), rotationAngles(rotationAngles), scale(scale) {}

    void setPosition(const Vector3& pos) { position = pos; }
    void setRotation(const Vector3& rot) { rotationAngles = rot; }
    void setScale(const Vector3& s) { scale = s; }

    void setX(float x) { position.x = x; }
    void setY(float y) { position.y = y; }
    void setZ(float z) { position.z = z; }

    void setRotationX(float rx) { rotationAngles.x = rx; }
    void setRotationY(float ry) { rotationAngles.y = ry; }
    void setRotationZ(float rz) { rotationAngles.z = rz; }

    void setScaleX(float sx) { scale.x = sx; }
    void setScaleY(float sy) { scale.y = sy; }
    void setScaleZ(float sz) { scale.z = sz; }

    const Vector3& getPosition() const { return position; }
    const Vector3& getRotationAngles() const { return rotationAngles; }
    const Vector3& getScale() const { return scale; }

    Vector3 getRotationAxis() const {
        Quaternion q = QuaternionFromEuler(
            DEG2RAD * rotationAngles.x,
            DEG2RAD * rotationAngles.y,
            DEG2RAD * rotationAngles.z
        );

        Vector3 axis;
        float angle;
        QuaternionToAxisAngle(q, &axis, &angle);
        return axis;
    }

    float getRotationAngle() const {
        Quaternion q = QuaternionFromEuler(
            DEG2RAD * rotationAngles.x,
            DEG2RAD * rotationAngles.y,
            DEG2RAD * rotationAngles.z
        );

        Vector3 axis;
        float angle;
        QuaternionToAxisAngle(q, &axis, &angle);
        return RAD2DEG * angle;
    }

    Matrix getTransformMatrix() const {
        Quaternion q = QuaternionFromEuler(
            DEG2RAD * rotationAngles.x,
            DEG2RAD * rotationAngles.y,
            DEG2RAD * rotationAngles.z
        );

        Matrix mRot = QuaternionToMatrix(q);
        Matrix mScale = MatrixScale(scale.x, scale.y, scale.z);
        Matrix mTrans = MatrixTranslate(position.x, position.y, position.z);

        return MatrixMultiply(MatrixMultiply(mScale, mRot), mTrans);
    }

private:
    Vector3 position;
    Vector3 rotationAngles; 
    Vector3 scale;
};
</file>

<file path="src/graphics/Render2D/Render2D.cpp">
#include "Render2D.hpp"
#include "../rica.hpp"
#include "Camera2D/Camera2D.hpp"
#include <iostream>

Render2DSystem& render2Dsystem = Render2DSystem::getInstance();

void Render2DSystem::update(const std::vector<std::shared_ptr<Entity>>& entities) {
  std::shared_ptr<Camera2DComponent> activeCamera = nullptr;
  for (auto entity : entities) {
    auto camera = entity->getComponent<Camera2DComponent>();
    if (camera && camera->isActiveCamera()) {
      activeCamera = camera;
      break;
    }
  }

  if (activeCamera) {
    BeginMode2D(activeCamera->getCamera2D());
  }

  for (auto entity : entities) {
    auto sprite = entity->getComponent<SpriteComponent>();
    auto transform = entity->getComponent<TransformComponent>();

    if (!sprite || !transform)
      continue;

    DrawTexturePro(sprite->getTexture(), sprite->getSource(),
                   transform->getDest(), transform->getOrigin(),
                   transform->getRotation(), sprite->getColor());
  }

  if (activeCamera) {
    EndMode2D();
  }

}
</file>

<file path="src/graphics/Render2D/Render2D.hpp">
#pragma once

#include <memory>
#include <vector>

class Entity;
class SpriteComponent;
class Camera2DComponent;
class TransformComponent;

class Engine;
class Render2DSystem {
public:
  Render2DSystem(const Render2DSystem&) = delete;
  Render2DSystem& operator=(const Render2DSystem&) = delete;
  Render2DSystem(Render2DSystem&&) = delete;
  Render2DSystem& operator=(Render2DSystem&&) = delete;

  static Render2DSystem& getInstance() {
    static Render2DSystem instance;
    return instance;
  }

  void update(const std::vector<std::shared_ptr<Entity>>& entities);

private:
  Render2DSystem() = default;
  ~Render2DSystem() = default;
};

extern Render2DSystem& render2Dsystem;
</file>

<file path="src/graphics/Render3D/Render3D.cpp">
#include "Render3D.hpp"
#include "../rica.hpp"
#include "Camera3D/Camera3D.hpp"
#include "Transform3D/Transform3D.hpp"
#include "raylib.h"
#include <iostream>

Render3DSystem& render3Dsystem = Render3DSystem::getInstance();

void Render3DSystem::update(const std::vector<std::shared_ptr<Entity>>& entities) {
  std::shared_ptr<Camera3DComponent> activeCamera = nullptr;
  for (auto entity : entities) {
    auto camera = entity->getComponent<Camera3DComponent>();
    if (camera && camera->isActiveCamera()) {
      activeCamera = camera;
      break;
    }
  }

  if (activeCamera) {
    BeginMode3D(activeCamera->getCamera3D());
  }

  for (auto entity : entities) {
    auto model = entity->getComponent<MeshComponent>();
    auto transform = entity->getComponent<Transform3DComponent>();

    if (!model || !transform)
      continue;

    if (!model->isLoaded()) continue;

       DrawModelEx(
            model->getModel(),
            transform->getPosition(),
            transform->getRotationAxis(),
            transform->getRotationAngle(), 
            transform->getScale(),
            model->getColor()
        );
 }

  if (activeCamera) {
    EndMode3D();
  }

}
</file>

<file path="src/graphics/Render3D/Render3D.hpp">
#pragma once

#include <memory>
#include <vector>

class Entity;
class SpriteComponent;
class Camera3DComponent;
class TransformComponent;
class Engine;

class Render3DSystem {
public:
  Render3DSystem(const Render3DSystem&) = delete;
  Render3DSystem& operator=(const Render3DSystem&) = delete;
  Render3DSystem(Render3DSystem&&) = delete;
  Render3DSystem& operator=(Render3DSystem&&) = delete;

  static Render3DSystem& getInstance() {
    static Render3DSystem instance;
    return instance;
  }

  void update(const std::vector<std::shared_ptr<Entity>>& entities);

private:
  Render3DSystem() = default;
  ~Render3DSystem() = default;
};

extern Render3DSystem& render3Dsystem;
</file>

<file path="src/Physic/Physic2D/Physic.hpp">
#pragma once

#include "Collider2D.hpp"
#include <memory>
#include <vector>

class Entity;
class TransformComponent;
class Collider2DComponent;
class Engine;

class Physic2D {
public:
  Physic2D(const Physic2D&) = delete;
  Physic2D& operator=(const Physic2D&) = delete;
  Physic2D(Physic2D&&) = delete;
  Physic2D& operator=(Physic2D&&) = delete;

  static Physic2D& getInstance() {
    static Physic2D instance;
    return instance;
  }

  void update(const std::vector<std::shared_ptr<Entity>>& entities);
  bool isColliding(std::shared_ptr<Entity> entity1,
                   std::shared_ptr<Entity> entity2);

private:
  Physic2D() = default;

  ~Physic2D() = default;
};

extern Physic2D& physic2D;
</file>

<file path="game/.gitignore">
logRica.txt
</file>

<file path="game/initEngine.json">
{
    "rayLib":{
         "windowTitle": "hello",

         "resolution": {
             "width": 1920,
             "height": 1080
         },

         "maxFPS": 60,

         "configurationFlags": [
            "FLAG_FULLSCREEN_MODE"
          ]
    }
}
</file>

<file path="src/Var/Var.cpp">
#include "Var.hpp"
#include "../rica.hpp"

std::string basePath = GetApplicationDirectory();
</file>

<file path="src/Var/Var.hpp">
#pragma once
#include <string>

extern std::string basePath;
</file>

<file path="game/xmake.lua">
target("MyGame")
    set_kind("binary")
    add_files("*.cpp")

    add_deps("EngineLib")

    add_packages("raylib", "rapidjson")
target_end()
</file>

<file path="src/ECS/Components/Physic/Physic2D/Physic2D.hpp">
#pragma once
#include "../../../../Logger/Logger.hpp"
#include "../../../../lib/raylib/src/raymath.h"
#include "../../Component.hpp"

class Physic2DComponent : public Component {
public:
  Physic2DComponent() {
  }

  friend class Physic2DComponent;

private:
  // Если true, объект не движется (как стена)
  bool isStatic = false;

  // масса
  float mass = 1;
  // центр массы
  Vector2 centerOfMassOffset = {0, 0};

  // насколько сильно гравитация мира действует на обьект
  float gravityScale = 1.0f;
  // действует ли графитация
  bool gravityActive = true;

  // упругость
  float restitution = 1;

  // трение
  float friction = 1;

  // сила
  float force = 0;

  // температура
  float temperature = 0;
};
</file>

<file path="src/ECS/Components/Sprite/Sprite.cpp">
#include "Sprite.hpp"
#include "../../../rica.hpp"

// Загрузка текстуры
bool SpriteComponent::LoadTextureSprite(const char* path) {
  // Если уже была текстура — разгрузим
  if (texture.id != 0)
    UnloadTexture(texture);

  texture = LoadTexture(path);

  if (texture.id == 0) {
    logger.addLog(LogLevel::ERROR, basePath, "Failed to load texture", "logRica.txt");
    logger.addLog(LogLevel::ERROR, basePath, "Failed to load texture");


    return false;
  }

  // Настраиваем прямоугольник источника
  source = {0, 0, (float)texture.width, (float)texture.height};
  color = WHITE;

  return true;
}

// Конструктор со std::string
SpriteComponent::SpriteComponent(const std::string& path) {
  LoadTextureSprite(path.c_str());
}
</file>

<file path="src/ECS/Components/Component.hpp">
#pragma once

struct Component {
  virtual ~Component() = default;
};
</file>

<file path="src/ECS/Objects/Entity.inl">
#pragma once
</file>

<file path="src/ECS/Systems/System.hpp">
#pragma once

#include <vector>

class Entity;

struct System {
  std::vector<Entity*> entities;

  virtual ~System() = default;

public:
  void addEntity(Entity* entity) {
    entities.push_back(entity);
  }
};
</file>

<file path="src/engine/Engine.inl">
#pragma once
#include "../Scene/Scene.hpp"
#include "Engine.hpp"

template <typename T>
std::shared_ptr<T> Engine::SceneManager::CreateScene(unsigned int ID) {
  if (ID >= Engine::vectorSceneManager.size()) {
    Engine::vectorSceneManager.resize(ID + 1, nullptr);
  }
  if (Engine::vectorSceneManager[ID] != nullptr) {
    Engine::vectorSceneManager[ID] = nullptr;
  }

  auto scenePtr = std::make_shared<T>();
  Engine::vectorSceneManager[ID] = scenePtr;
  sceneCurrent = ID;
  scenePtr->OnLoad();
  return scenePtr;
}
</file>

<file path="src/graphics/Terminal.cpp">
#include "Terminal.hpp"

Terminal& terminal = Terminal::getInstance();
</file>

<file path="src/graphics/Terminal.hpp">
#pragma once

#include <cstdint>
#include <cstdio>
#include <iostream>
#include <string>
#include <unistd.h>

class Terminal {
public:
  // Паттерн Singleton
  Terminal(const Terminal&) = delete;
  Terminal& operator=(const Terminal&) = delete;
  Terminal(Terminal&&) = delete;
  Terminal& operator=(Terminal&&) = delete;

  static Terminal& getInstance() {
    static Terminal instance;
    return instance;
  }

  // Публичные методы
  void clear() {
    wprintf(L"\033[2J\033[H");
    fflush(stdout);
  }

  void clearArea(int startX, int startY, int endX, int endY) {
    wprintf(L"\033[s");
    fflush(stdout);

    for (int y = startY; y <= endY; y++) {
      wprintf(L"\033[%d;%dH", y, startX);
      int count = endX - startX + 1;
      if (count > 0) {
        wprintf(L"\033[%dX", count);
      }
      fflush(stdout);
    }

    wprintf(L"\033[u");
    fflush(stdout);
  }

  void put(int x, int y, wchar_t symbol) {
    wprintf(L"\033[%d;%dH%lc", y + 1, x + 1, symbol);
    fflush(stdout);
  }

  void setForegroundColor(uint8_t r, uint8_t g, uint8_t b) {
    wprintf(L"\033[38;2;%d;%d;%dm", r, g, b);
    fflush(stdout);
  }

  void setBackgroundColor(uint8_t r, uint8_t g, uint8_t b) {
    wprintf(L"\033[48;2;%d;%d;%dm", r, g, b);
    fflush(stdout);
  }

  void resetColor() {
    wprintf(L"\033[0m");
    fflush(stdout);
  }

  void runCommand(const std::wstring& command) {
    wprintf(L"%ls", command.c_str());
    fflush(stdout);
  }

  void setCursorPosition(int x, int y) {
    wprintf(L"\033[%d;%dH", y, x);
    fflush(stdout);
  }

  void hideCursor() {
    wprintf(L"\033[?25l");
    fflush(stdout);
  }

  void showCursor() {
    wprintf(L"\033[?25h");
    fflush(stdout);
  }

  void saveCursor() {
    wprintf(L"\033[s");
    fflush(stdout);
  }

  void restoreCursor() {
    wprintf(L"\033[u");
    fflush(stdout);
  }

  // Получить размер терминала
  void getSize() {
  }

private:
  Terminal() = default;
  ~Terminal() {
    // Восстанавливаем настройки при разрушении
    resetColor();
    showCursor();
    fflush(stdout);
  }
};

// Глобальная ссылка для удобства
extern Terminal& terminal;
</file>

<file path="src/Logger/Logger.cpp">
#include "Logger.hpp"

Log& logger = Log::getInstance();

std::string Log::levelToString(LogLevel level) {
  switch (level) {
  case LogLevel::DEBUG:
    return "DEBUG";
  case LogLevel::INFO:
    return "INFO";
  case LogLevel::WARNING:
    return "WARNING";
  case LogLevel::ERROR:
    return "ERROR";
  case LogLevel::CRITICAL:
    return "CRITICAL";
  default:
    return "UNKNOWN";
  }
}

bool Log::addLog(LogLevel type, std::string module, std::string msg,
                 std::string path) {
  // текущее время
  auto now = std::chrono::system_clock::now();
  std::time_t time = std::chrono::system_clock::to_time_t(now);
  std::tm* local_time = std::localtime(&time);

  // файл
  std::fstream file(path, std::ios::app);
  if (!file.is_open())
    return false;

  // логирование
  file << "[" << local_time->tm_year + 1900 << "-" << local_time->tm_mon + 1
       << "-" << local_time->tm_mday << " " << local_time->tm_hour << ":"
       << local_time->tm_min << ":" << local_time->tm_sec << "] "
       << "[" << levelToString(type) << "] [" << module << "] -" << msg
       << std::endl;

  file.close();
  return true;
}

bool Log::addLog(LogLevel type, std::string module, std::string msg) {
  auto now = std::chrono::system_clock::now();
  std::time_t time = std::chrono::system_clock::to_time_t(now);
  std::tm* local_time = std::localtime(&time);

  // Цвет в зависимости от уровня (ANSI escape коды)
  const char* colorCode = "\033[0m";
  switch (type) {
  case DEBUG:
    colorCode = "\033[38;2;150;150;150m";
    break;
  case INFO:
    colorCode = "\033[38;2;100;200;100m";
    break;
  case WARNING:
    colorCode = "\033[38;2;255;200;0m";
    break;
  case ERROR:
    colorCode = "\033[38;2;255;100;100m";
    break;
  case CRITICAL:
    colorCode = "\033[38;2;255;0;0m";
    break;
  }

  printf("%s[%d-%d-%d %d:%d:%d] [%s] [%s] - %s\033[0m\n", colorCode,
         local_time->tm_year + 1900, local_time->tm_mon + 1,
         local_time->tm_mday, local_time->tm_hour, local_time->tm_min,
         local_time->tm_sec, levelToString(type).c_str(), module.c_str(),
         msg.c_str());
  fflush(stdout);

  return true;
}
</file>

<file path="src/Logger/Logger.hpp">
#pragma once
#include <chrono>
#include <ctime>
#include <fstream>
#include <string>

enum LogLevel { DEBUG, INFO, WARNING, ERROR, CRITICAL };

class Log {
public:
  Log(const Log&) = delete;
  Log& operator=(const Log&) = delete;
  Log(Log&&) = delete;
  Log& operator=(Log&&) = delete;

  static Log& getInstance() {
    static Log instance;
    return instance;
  }

  bool addLog(LogLevel type, std::string module, std::string msg,
              std::string path);
  bool addLog(LogLevel type, std::string module, std::string msg);

private:
  Log() = default;
  ~Log() = default;

  std::string levelToString(LogLevel level);
};

extern Log& logger;
</file>

<file path="src/Scene/Scene.inl">
#pragma once
#include "../ECS/Objects/Entity.hpp"
#include "Scene.hpp"

template <typename T, typename... Args>
std::shared_ptr<T> Scene::Create(Args&&... args) {
  T* entityPtr = new T(std::forward<Args>(args)...);
  if (entityPtr != nullptr) {
    createEntity(entityPtr);
    entityPtr->Start();
  }
  return entityPtr;
}
</file>

<file path="src/UI/UI.hpp">
#pragma once

class UI {};
</file>

<file path="src/Audio/Audio.cpp">
#include "../rica.hpp"
#include "Var/Var.hpp"
#include <algorithm>
#include <cmath>
#include <linux/limits.h>

AudioSystem& audioSystem = AudioSystem::getInstance();

void AudioSystem::update(const std::vector<std::shared_ptr<Entity>>& entities) {
  logger.addLog(LogLevel::DEBUG, basePath, __func__, "logRica.txt");

  std::shared_ptr<Camera2DComponent> cameraActive = nullptr;
  std::shared_ptr<TransformComponent> transformActive = nullptr;

  for (auto entity : entities) {
    auto camera = entity->getComponent<Camera2DComponent>();
    auto transform = entity->getComponent<TransformComponent>();

    if (camera && camera->isActiveCamera() && transform) {
      cameraActive = camera;
      transformActive = transform;
      break;
    }
  }

  for (auto entity : entities) {
    auto transform = entity->getComponent<TransformComponent>();
    auto audio = entity->getComponent<AudioComponent>();

    if (!transform || !audio)
      continue;

    if (cameraActive != nullptr && transformActive != nullptr) {
      float dx = transformActive->getPosition().x - transform->getPosition().x;
      float dy = transformActive->getPosition().y - transform->getPosition().y;

      float l = sqrt(dx * dx + dy * dy);

      float l1_max = sqrt((GetMonitorWidth(0) * GetMonitorWidth(0)) +
                          (GetMonitorHeight(0) * GetMonitorHeight(0)));

      if (l1_max > 0.0f) {
        float normalized_distance = l / l1_max;

        float volume = 1.0f - normalized_distance;

        if (volume < 0.0f) {
          volume = 0.0f;
        }

        audio->setVolumeAll(volume);
      }

      float deltax =
          transform->getPosition().x - transformActive->getPosition().x;
      float clamped_value =
          std::clamp(deltax / GetMonitorWidth(0), -1.0f, 1.0f);
      float pan_value = (1.0f - clamped_value) / 2.0f;
      audio->setPanAll(pan_value);
    }
  }
}
</file>

<file path="src/Audio/Audio.hpp">
#pragma once

#include <memory>
#include <vector>

class Entity;
class TransformComponent;
class Engine;

class AudioSystem {
public:
  AudioSystem(const AudioSystem&) = delete;
  AudioSystem& operator=(const AudioSystem&) = delete;
  AudioSystem(AudioSystem&&) = delete;
  AudioSystem& operator=(AudioSystem&&) = delete;

  static AudioSystem& getInstance() {
    static AudioSystem instance;
    return instance;
  }

  void update(const std::vector<std::shared_ptr<Entity>>& entities);

private:
  AudioSystem() = default;

  ~AudioSystem() = default;
};

extern AudioSystem& audioSystem;
</file>

<file path="src/Collider/Collider2D/Collider2D.cpp">
#include "Collider2D.hpp"
#include "../../rica.hpp"

Collider2DSystem& collider2DSystem = Collider2DSystem::getInstance();

void Collider2DSystem::update(
    const std::vector<std::shared_ptr<Entity>>& entities) {
  logger.addLog(LogLevel::DEBUG, basePath, __func__, "logRica.txt");


  for (auto entity : entities) {
    auto transform = entity->getComponent<TransformComponent>();
    auto collider = entity->getComponent<Collider2DComponent>();

    if (!transform || !collider)
      continue;

    collider->setX(transform->getPosition().x);
    collider->setY(transform->getPosition().y);
  }
}

bool Collider2DSystem::isColliding(std::shared_ptr<Entity> entity1,
                                   std::shared_ptr<Entity> entity2) {
  auto transform1 = entity1->getComponent<TransformComponent>();
  auto collider1 = entity1->getComponent<Collider2DComponent>();
  auto transform2 = entity2->getComponent<TransformComponent>();
  auto collider2 = entity2->getComponent<Collider2DComponent>();

  if (!transform1 || !collider1 || !transform2 || !collider2) {
    return false;
  }

  float left1 = collider1->getPosition().x - collider1->getWidth();
  float right1 = collider1->getPosition().x;
  float top1 = collider1->getPosition().y - collider1->getHeight();
  float bottom1 = collider1->getPosition().y;

  float left2 = collider2->getPosition().x - collider2->getWidth();
  float right2 = collider2->getPosition().x;
  float top2 = collider2->getPosition().y - collider2->getHeight();
  float bottom2 = collider2->getPosition().y;

  return (left1 < right2 && right1 > left2 && top1 < bottom2 && bottom1 > top2);
}
</file>

<file path="src/Collider/Collider2D/Collider2D.hpp">
#pragma once

#include <memory>
#include <vector>

class Entity;
class SpriteComponent;
class TransformComponent;
class Engine;

class Collider2DSystem {
public:
  Collider2DSystem(const Collider2DSystem&) = delete;
  Collider2DSystem& operator=(const Collider2DSystem&) = delete;
  Collider2DSystem(Collider2DSystem&&) = delete;
  Collider2DSystem& operator=(Collider2DSystem&&) = delete;

  static Collider2DSystem& getInstance() {
    static Collider2DSystem instance;
    return instance;
  }

  void update(const std::vector<std::shared_ptr<Entity>>& entities);
  bool isColliding(std::shared_ptr<Entity> entity1,
                   std::shared_ptr<Entity> entity2);

private:
  Collider2DSystem() = default;

  ~Collider2DSystem() = default;
};

extern Collider2DSystem& collider2DSystem;
</file>

<file path="src/ECS/Components/Audio/Audio.hpp">
#pragma once
#include "../../../Logger/Logger.hpp"
#include "../Component.hpp"
#include <raylib.h>
#include <raymath.h>
#include <string>
#include <unordered_map>
#include <vector>
#include "../../../rica.hpp"

class Log;
enum LogLevel;

class AudioComponent : public Component {
public:
  AudioComponent() {
  }

  void addSound(const std::string& tag, const std::string& path) {
    if (tag.empty() || path.empty()) {
      logger.addLog(LogLevel::DEBUG, basePath, __func__, "logRica.txt");

      return;
    }
    Sound sound = LoadSound(path.c_str());
    audioVector.push_back({tag, path, sound, false});
    tagToIndex[tag] = audioVector.size() - 1;
  }

  ~AudioComponent() {
    for (auto& audio : audioVector) {
      UnloadSound(audio.sound);
    }
  }

  void play(const std::string& tag) {
    auto it = tagToIndex.find(tag);
    if (it != tagToIndex.end()) {
      size_t idx = it->second;
      PlaySound(audioVector[idx].sound);
      audioVector[idx].isPlaying = true;
    }
  }

  void stop(const std::string& tag) {
    auto it = tagToIndex.find(tag);
    if (it != tagToIndex.end()) {
      size_t idx = it->second;
      StopSound(audioVector[idx].sound);
      audioVector[idx].isPlaying = false;
    }
  }

  void pause(const std::string& tag) {
    auto it = tagToIndex.find(tag);
    if (it != tagToIndex.end()) {
      PauseSound(audioVector[it->second].sound);
    }
  }

  void resume(const std::string& tag) {
    auto it = tagToIndex.find(tag);
    if (it != tagToIndex.end()) {
      ResumeSound(audioVector[it->second].sound);
    }
  }

  void setVolume(const std::string& tag, float volume) {
    auto it = tagToIndex.find(tag);
    if (it != tagToIndex.end()) {
      SetSoundVolume(audioVector[it->second].sound, volume);
    }
  }

  void setVolumeAll(float volume) {
    for (auto& audio : audioVector) {
      SetSoundVolume(audio.sound, volume);
    }
  }

  void setPitch(const std::string& tag, float pitch) {
    auto it = tagToIndex.find(tag);
    if (it != tagToIndex.end()) {
      SetSoundPitch(audioVector[it->second].sound, pitch);
    }
  }

  void setPan(const std::string& tag, float pan) {
    auto it = tagToIndex.find(tag);
    if (it != tagToIndex.end()) {
      SetSoundPan(audioVector[it->second].sound, pan);
    }
  }

  void setPanAll(float pan) {
    for (auto& audio : audioVector) {
      SetSoundPan(audio.sound, pan);
    }
  }

  bool hasPlayingSounds() const {
    for (const auto& audio : audioVector) {
      if (audio.isPlaying && IsSoundPlaying(audio.sound)) {
        return true;
      }
    }
    return false;
  }

  const std::vector<size_t> getPlayingIndices() const {
    std::vector<size_t> indices;
    for (size_t i = 0; i < audioVector.size(); ++i) {
      if (audioVector[i].isPlaying && IsSoundPlaying(audioVector[i].sound)) {
        indices.push_back(i);
      }
    }
    return indices;
  }

private:
  struct AudioData {
    std::string tag;
    std::string path;
    Sound sound;
    bool isPlaying = false;
  };

  std::vector<AudioData> audioVector;
  std::unordered_map<std::string, size_t> tagToIndex;
};
</file>

<file path="src/ECS/Components/Camera/Camera2D/Camera2D.hpp">
#pragma once
#include "../../Component.hpp"
#include <raylib.h>
#include <raymath.h>

class Camera2DComponent : public Component {
public:
  Camera2DComponent() = default;

  Camera2DComponent(Vector2 offset, float zoom = 1.0f, bool isActive = true)
      : offset(offset), zoom(zoom), isActive(isActive) {
  }

  Camera2D getCamera2D() const {
    Camera2D cam;
    cam.target = target;
    cam.offset = offset;
    cam.rotation = rotation;
    cam.zoom = zoom;
    return cam;
  }

  void followTarget(Vector2 position) {
    target = position;
  }

  void smoothFollow(Vector2 position, float speed) {
    target.x += (position.x - target.x) * speed;
    target.y += (position.y - target.y) * speed;
  }

  void setTarget(Vector2 target) {
    this->target = target;
  }
  void setOffset(Vector2 offset) {
    this->offset = offset;
  }
  void setRotation(float rotation) {
    this->rotation = rotation;
  }
  void setZoom(float zoom) {
    this->zoom = zoom;
  }
  void setActive(bool isActive) {
    this->isActive = isActive;
  }

  // Getters
  Vector2 getTarget() const {
    return target;
  }
  Vector2 getOffset() const {
    return offset;
  }
  float getRotation() const {
    return rotation;
  }
  float getZoom() const {
    return zoom;
  }
  bool isActiveCamera() const {
    return isActive;
  }

private:
  Vector2 target{0, 0};
  Vector2 offset{0, 0};
  float rotation = 0.0f;
  float zoom = 1.0f;
  bool isActive = false;
};
</file>

<file path="src/ECS/Components/Sprite/Sprite.hpp">
#pragma once

#include "../../../Logger/Logger.hpp"
#include "../Component.hpp"
#include <raylib.h>

#include <string>

class SpriteComponent : public Component {
public:
  // Удобный современный конструктор
  SpriteComponent(const std::string& path);

  // Функция загрузки текстуры (const char*, как требует Raylib)
  bool LoadTextureSprite(const char* path);

  void setColor(Color color) {
    this->color = color;
  }
  void setSource(float x, float y, float width, float height) {
    source = {x, y, width, height};
  }

  int getHeightSprite() {
    return texture.height;
  }
  int getWidthSprite() {
    return texture.width;
  }
  Color getColor() {
    return color;
  }
  Texture2D getTexture() {
    return texture;
  }
  Rectangle getSource() {
    return source;
  }

private:
  Texture2D texture{0}; // Инициализация Raylib стиля
  Color color = WHITE;
  Rectangle source{0, 0, 0, 0};
};
</file>

<file path="src/Scene/Scene.hpp">
#pragma once
#include <memory>
#include <optional>
#include <string>
#include <vector>

class Entity;

class Scene {
public:
  Scene();
  virtual ~Scene();

  // Lifecycle методы - переопределяет пользователь
  virtual void OnLoad() {
  }
  virtual void OnUpdate(float deltaTime) {
  }
  virtual void OnUnload() {
  }

  // Создание Entity (старый API)
  std::shared_ptr<Entity>
  createEntity(std::shared_ptr<Entity> entity);

  // Создание Entity (новый API)
  template <typename T, typename... Args>
  std::shared_ptr<T> Create(Args&&... args);

  // Поиск Entity
  std::optional<std::shared_ptr<Entity>> findById(int id);
  std::vector<std::shared_ptr<Entity>> findByTag(const std::string& tag);
  const std::vector<std::shared_ptr<Entity>>& getAllEntities() const;

  // Обновление
  void updateEntity();

private:
  std::vector<std::shared_ptr<Entity>> entities;
};

#include "Scene.inl"
</file>

<file path="src/xmake.lua">
target("EngineLib")
    set_kind("static")
    add_files(
        "Audio/*.cpp",
        "Collider/**/*.cpp",
        "ECS/**/*.cpp",
        "engine/*.cpp",
        "graphics/**/*.cpp", 
        "Logger/*.cpp",
        "Scene/*.cpp",
        "UI/*.cpp",
        "Var/*.cpp"
    )

    add_includedirs(
        ".",
        "ECS/Components/",
        "ECS/Components/Audio/",
        "ECS/Components/Camera/",
        "ECS/Components/Collider/Collider2D/",
        "ECS/Components/Collider/Collider3D/",
        "ECS/Components/Physic/",
        "ECS/Components/Sprite/",
        "ECS/Components/Transform/",
        "ECS/Objects/",
        "ECS/Systems/",
        "Collider/",
        "Collider/Collider2D/",
        "engine/",
        "graphics/",
        "Logger/",
        "Scene/",
        "UI/"
    )

    add_packages("raylib", "rapidjson")
target_end()
</file>

<file path="src/ECS/Objects/Entity.cpp">
#include "Entity.hpp"
#include "../../rica.hpp"
#include <iostream>
#include "../Components/Camera/Camera3D/Camera3D.hpp"
#include "../Components/Mesh/Mesh.hpp"
#include "../Components/Transform/Transform3D/Transform3D.hpp"

static int globalEntityId = 0;

Entity::Entity() : id(globalEntityId++) {
}

Entity::Entity(std::string tag) : id(globalEntityId++), tag(tag) {
}

Entity::~Entity() = default;

int Entity::getID() const {
  return id;
}

void Entity::addComponent(std::shared_ptr<Component> comp) {
  if (comp != nullptr) {
    components.push_back(comp);
  }
}

template <typename T> std::shared_ptr<T> Entity::getComponent() {
  for (auto componentPtr : components) {
    if (componentPtr == nullptr)
      continue;

    if (auto casted = std::dynamic_pointer_cast<T>(componentPtr)) {
      return casted;
    }
  }
  return nullptr;
}

template std::shared_ptr<SpriteComponent>
Entity::getComponent<SpriteComponent>();
template std::shared_ptr<TransformComponent>
Entity::getComponent<TransformComponent>();
template std::shared_ptr<Collider2DComponent>
Entity::getComponent<Collider2DComponent>();
template std::shared_ptr<AudioComponent> Entity::getComponent<AudioComponent>();
template std::shared_ptr<Camera2DComponent>
Entity::getComponent<Camera2DComponent>();

template std::shared_ptr<Camera3DComponent>
Entity::getComponent<Camera3DComponent>();
template std::shared_ptr<MeshComponent>
Entity::getComponent<MeshComponent>();
template std::shared_ptr<Transform3DComponent>
Entity::getComponent<Transform3DComponent>();
</file>

<file path="src/ECS/Objects/Entity.hpp">
#pragma once

#include <memory>
#include <optional>
#include <string>
#include <vector>

struct Component;

class Entity {
public:
  Entity();
  Entity(std::string tag);
  virtual ~Entity();

  virtual void Start() {
  }
  virtual void update(float deltaTime) {
  }

  void addComponent(std::shared_ptr<Component> comp);
  template <typename T> std::shared_ptr<T> getComponent();

  int getID() const;

  void setTag(std::string tag) {
    this->tag = tag;
  }
  std::string getTag() {
    return tag;
  }

private:
  std::vector<std::shared_ptr<Component>> components;
  int id;
  std::string tag;
};

#include "Entity.inl"
</file>

<file path="src/engine/Engine.hpp">
#pragma once

#include <memory>
#include <shared_mutex>
#include <vector>

class Scene;
class Render2DSystem;
class Collider2DComponent;

class Engine {
public:
  // движок
  Engine(const Engine&) = delete;
  Engine& operator=(const Engine&) = delete;
  Engine(Engine&&) = delete;
  Engine& operator=(Engine&&) = delete;

  static Engine& getInstance() {
    static Engine instance;
    return instance;
  }

  void update();
  bool init();
  void set3Dmode(const bool& is3D){
    this->is3D = is3D;
  }
  bool is3Dmode() const {
    return is3D;
  }
  bool getIsRunning() {
    return isRunning;
  }
  void setIsRunning(bool isRunning) {
    this->isRunning = isRunning;
  }
  void deleteVectorSceneManager();
  void shutdown();

  float getDeltaTime() const {
    return deltaTime;
  }

  friend int main();


  class SceneManager {
  public:
    std::shared_ptr<Scene> newSceneByID(unsigned int ID);
    void setSceneByID(unsigned int ID);
    void setSceneLimit(unsigned int limit);
    unsigned int getCurrentSceneID() const {
      return sceneCurrent;
    }
    void addComponentCurrentScene();

    template <typename T> std::shared_ptr<T> CreateScene(unsigned int ID);

    friend class Engine;

  private:
    unsigned int sceneCurrent = 0;
  };

  static SceneManager sceneManager;
  std::shared_ptr<Scene> getActiveScene() {
    unsigned int currentSceneId = sceneManager.getCurrentSceneID();
    if (currentSceneId < vectorSceneManager.size()) {
      return vectorSceneManager[currentSceneId];
    }
    return nullptr;
  }

private:
  static std::vector<std::shared_ptr<Scene>> vectorSceneManager;

  void updateCurrentScene();
  bool is3D=false;
  bool isRunning = true;
  Engine() = default;
  ~Engine() = default;

  float deltaTime = 0.0f;
};

bool gameStart();

extern Engine& engine;

#include "Engine.inl"
</file>

<file path="src/Scene/Scene.cpp">
#include "Scene.hpp"
#include "../rica.hpp"

Scene::Scene() {
}

Scene::~Scene() = default;

std::shared_ptr<Entity> Scene::createEntity(std::shared_ptr<Entity> entityPtr) {
  if (entityPtr != nullptr) {
    entities.push_back(entityPtr);
  }
  return entityPtr;
}

std::optional<std::shared_ptr<Entity>> Scene::findById(int id) {
  for (auto entityPtr : entities) {
    if (entityPtr != nullptr && entityPtr->getID() == id) {
      return entityPtr;
    }
  }
  return {};
}

std::vector<std::shared_ptr<Entity>> Scene::findByTag(const std::string& tag) {
  std::vector<std::shared_ptr<Entity>> resultVector;
  for (auto entityPtr : entities) {
    if (entityPtr != nullptr && entityPtr->getTag() == tag) {
      resultVector.push_back(entityPtr);
    }
  }
  return resultVector;
}

const std::vector<std::shared_ptr<Entity>>& Scene::getAllEntities() const {
  return entities;
}

void Scene::updateEntity() {
  for (auto entityPtr : entities) {
    if (entityPtr != nullptr) {
      entityPtr->update(0.0f);
    }
  }
}
</file>

<file path="src/rica.hpp">
#pragma once

// Предварительные объявления
struct Component;
class SpriteComponent;
class TransformComponent;
class Camera2DComponent;
class Entity;
class Player;
class Terminal;
class Log;
class Collider2DSystem;
class Render2DSystem;
class AudioSystem;

#include <raylib.h>
#include <raymath.h>

#include <rapidjson/document.h>

#include <memory>
#include <string>
#include <vector>

// переменные
#include "Var/Var.hpp"

#include "Logger/Logger.hpp"

// Компоненты ECS
#include "ECS/Components/Audio/Audio.hpp"
#include "ECS/Components/Camera/Camera2D/Camera2D.hpp"
#include "ECS/Components/Collider/Collider2D/Collider2D.hpp"
#include "ECS/Components/Component.hpp"
#include "ECS/Components/Sprite/Sprite.hpp"
#include "ECS/Components/Mesh/Mesh.hpp"
#include "ECS/Components/Transform/Transform2D/Transform.hpp"
#include "ECS/Components/Transform/Transform3D/Transform3D.hpp"

// Объекты ECS
#include "ECS/Objects/Entity.hpp"

// системы
#include "Audio/Audio.hpp"
#include "Collider/Collider2D/Collider2D.hpp"
#include "graphics/Render2D/Render2D.hpp"
#include "graphics/Render3D/Render3D.hpp"

// Мир
#include "Scene/Scene.hpp"

// Движок
#include "engine/Engine.hpp"
</file>

<file path="game/main.cpp">
#include "../src/ECS/Components/Camera/Camera3D/Camera3D.hpp"   
#include "../src/rica.hpp"
#include "../src/engine/Engine.hpp"

#include <iostream>
#include "player.hpp"

class GameScene : public Scene {
private:
    std::shared_ptr<Player> player;
    std::shared_ptr<Entity> cameraEntity;

public:
    GameScene() {
        // CAMERA 3D
        cameraEntity = std::make_shared<Entity>();

        auto cam3D = std::make_shared<Camera3DComponent>(
            Vector3{0.0f, 5.0f, 10.0f},
            75.0f,
            true
        );

        cameraEntity->addComponent(cam3D);
        this->createEntity(cameraEntity);

        // PLAYER
        player = std::make_shared<Player>();
        this->createEntity(player);
    }

    void OnUpdate(float dt) override {
        if (player) player->update(dt);

        auto cam = cameraEntity->getComponent<Camera3DComponent>();
        auto trans = player->getComponent<Transform3DComponent>();

        if (cam && trans)
            cam->setTarget(trans->getPosition());
    }
};

bool gameStart() {
    if (!engine.init()) return false;

    engine.set3Dmode(true);

    engine.sceneManager.setSceneLimit(10);
    engine.sceneManager.CreateScene<GameScene>(1);

    return true;
}
</file>

<file path="xmake.lua">
add_rules("mode.debug", "mode.release")
add_rules("plugin.compile_commands.autoupdate", {outputdir = "build"}) -- generate compile commands

set_policy("build.sanitizer.address", true) -- sanitizers
set_policy("build.sanitizer.leak", true)

-- libs
add_requires("raylib", {external=false})
add_requires("rapidjson", {external=false})
set_warnings("all") -- warns
set_languages("c++17")

includes("src", "game")
</file>

<file path="src/engine/Engine.cpp">
#include "Engine.hpp"

#include "../rica.hpp"
#include "Var/Var.hpp"

#include <cstddef>
#include <fstream>
#include <string> // Добавлен для std::stoi

// Глобальная переменная движка (Engine Singleton)
Engine& engine = Engine::getInstance();

bool parseInitFile(rapidjson::Document& doc) {
  std::fstream initFile("initEngine.json");
  if (!initFile.is_open()) {
    logger.addLog(LogLevel::ERROR, basePath, "Failed to load initEngine.json", "logRica.txt");
    logger.addLog(LogLevel::ERROR, basePath, "Failed to load initEngine.json");

    return false;
  }
  std::string initString((std::istreambuf_iterator<char>(initFile)),
                         std::istreambuf_iterator<char>());
  doc.Parse(initString.c_str());
  if (doc.HasParseError()) {
    logger.addLog(LogLevel::ERROR, basePath, "Failed to parse JSON for position"+std::to_string(doc.GetErrorOffset()), "logRica.txt");
    logger.addLog(LogLevel::ERROR, basePath, "Failed to parse JSON for position"+std::to_string(doc.GetErrorOffset()));

    return false;
  }
  return true;
}

unsigned int GetFlagValue(const char* flagName) {
  if (strcmp(flagName, "FLAG_FULLSCREEN_MODE") == 0)
    return FLAG_FULLSCREEN_MODE;
  if (strcmp(flagName, "FLAG_WINDOW_RESIZABLE") == 0)
    return FLAG_WINDOW_RESIZABLE;
  if (strcmp(flagName, "FLAG_WINDOW_UNDECORATED") == 0)
    return FLAG_WINDOW_UNDECORATED;
  if (strcmp(flagName, "FLAG_WINDOW_HIDDEN") == 0)
    return FLAG_WINDOW_HIDDEN;
  if (strcmp(flagName, "FLAG_WINDOW_MINIMIZED") == 0)
    return FLAG_WINDOW_MINIMIZED;
  if (strcmp(flagName, "FLAG_WINDOW_MAXIMIZED") == 0)
    return FLAG_WINDOW_MAXIMIZED;
  if (strcmp(flagName, "FLAG_WINDOW_UNFOCUSED") == 0)
    return FLAG_WINDOW_UNFOCUSED;
  if (strcmp(flagName, "FLAG_WINDOW_TOPMOST") == 0)
    return FLAG_WINDOW_TOPMOST;
  if (strcmp(flagName, "FLAG_WINDOW_ALWAYS_RUN") == 0)
    return FLAG_WINDOW_ALWAYS_RUN;
  if (strcmp(flagName, "FLAG_WINDOW_TRANSPARENT") == 0)
    return FLAG_WINDOW_TRANSPARENT;

  if (strcmp(flagName, "FLAG_VSYNC_HINT") == 0)
    return FLAG_VSYNC_HINT;
  if (strcmp(flagName, "FLAG_MSAA_4X_HINT") == 0)
    return FLAG_MSAA_4X_HINT;
  if (strcmp(flagName, "FLAG_INTERLACED_HINT") == 0)
    return FLAG_INTERLACED_HINT;
  return 0;
}
struct RayLibVar {
  int width = 200;
  int height = 400;
  std::string title = "Default Game Title";
  int maxFPS = 60;
  unsigned int flag = 0;
};

std::optional<RayLibVar> parseInitFileForRayLib() {
  RayLibVar rayVar;
  rayVar.flag = 0;
  rapidjson::Document doc;

  if (!parseInitFile(doc))
    return {};

  // Ранний выход, если нет корневого объекта "rayLib"
  if (!doc.HasMember("rayLib") || !doc["rayLib"].IsObject())
    return {};

  const rapidjson::Value& config = doc["rayLib"];

  // 1. Парсинг заголовка и FPS
  if (config.HasMember("windowTitle") && config["windowTitle"].IsString())
    rayVar.title = config["windowTitle"].GetString();
  if (config.HasMember("maxFPS") && config["maxFPS"].IsInt())
    rayVar.maxFPS = config["maxFPS"].GetInt();

  // 2. Парсинг разрешения и флагов
  if (config.HasMember("resolution") && config["resolution"].IsObject()) {
    const rapidjson::Value& resolution = config["resolution"];

    auto parseDimension = [&](const char* key, int& dimension) {
      if (!resolution.HasMember(key))
        return;
      const rapidjson::Value& value = resolution[key];
      if (value.IsInt()) {
        dimension = value.GetInt();
      } else if (value.IsString()) {
        std::string strValue = value.GetString();
      }
    };

    parseDimension("width", rayVar.width);
    parseDimension("height", rayVar.height);

    if (config.HasMember("configurationFlags") &&
        config["configurationFlags"].IsArray()) {
      const rapidjson::Value& flagsArray = config["configurationFlags"];
      for (rapidjson::SizeType i = 0; i < flagsArray.Size(); i++) {
        if (flagsArray[i].IsString()) {
          const char* flagString = flagsArray[i].GetString();
          rayVar.flag += GetFlagValue(flagString);
        }
      }
    }
  }

  SetConfigFlags(rayVar.flag);
  InitWindow(rayVar.width, rayVar.height, rayVar.title.c_str());
  SetTargetFPS(rayVar.maxFPS);

  return rayVar;
}

bool Engine::init() {
  SetTraceLogLevel(LOG_ALL);
  InitAudioDevice();

  isRunning = true;
  auto var = parseInitFileForRayLib();
  // можно использовать var.has_value(), но лучше оставить так для
  // читабельности
  if (!var)
    return false;
  return true;
}

void Engine::update() {
}

void Engine::deleteVectorSceneManager() {
  vectorSceneManager.clear();
}

void Engine::shutdown() {
  CloseWindow();
}

std::vector<std::shared_ptr<Scene>> Engine::vectorSceneManager;
Engine::SceneManager Engine::sceneManager;

void Engine::updateCurrentScene() {
    logger.addLog(LogLevel::DEBUG, basePath, __func__, "logRica.txt");
  unsigned int currentSceneId = sceneManager.getCurrentSceneID();
  if (currentSceneId < vectorSceneManager.size() &&
      vectorSceneManager[currentSceneId] != nullptr) {
    vectorSceneManager[currentSceneId]->updateEntity();
  }
}

std::shared_ptr<Scene> Engine::SceneManager::newSceneByID(unsigned int ID) {
  if (ID >= Engine::vectorSceneManager.size()) {

    logger.addLog(LogLevel::CRITICAL, basePath,"World ID " + std::to_string(ID)+" is out of bounds! Resizing vector." , "logRica.txt");
    logger.addLog(LogLevel::CRITICAL, basePath,"World ID " + std::to_string(ID)+" is out of bounds! Resizing vector.");

    Engine::vectorSceneManager.resize(ID + 1, nullptr);
  }
  if (Engine::vectorSceneManager[ID] != nullptr) {
    Engine::vectorSceneManager[ID] = nullptr;
  }
  auto scenePtr = std::make_shared<Scene>();
  Engine::vectorSceneManager[ID] = scenePtr;
  return scenePtr;
}

void Engine::SceneManager::setSceneByID(unsigned int ID) {
  if (ID >= vectorSceneManager.size()) {
    logger.addLog(LogLevel::CRITICAL, basePath,"Cannot set scene ID " + std::to_string(ID)+": out of bounds", "logRica.txt");
    logger.addLog(LogLevel::CRITICAL, basePath,"Cannot set scene ID " + std::to_string(ID)+": out of bounds");
    return;
  }
  if (vectorSceneManager[ID] == nullptr) {
    logger.addLog(LogLevel::CRITICAL, basePath,"Cannot set scene ID " + std::to_string(ID)+": scene is null", "logRica.txt");
    logger.addLog(LogLevel::CRITICAL, basePath,"Cannot set scene ID " + std::to_string(ID)+": scene is null");

    return;
  }
  sceneCurrent = ID;
}

void Engine::SceneManager::setSceneLimit(unsigned int limit) {
  if (limit > Engine::vectorSceneManager.size()) {
    Engine::vectorSceneManager.resize(limit, nullptr);
  } else if (limit < Engine::vectorSceneManager.size()) {
    for (int i = limit; i < (int)Engine::vectorSceneManager.size(); i++) {
      if (Engine::vectorSceneManager[i] != nullptr) {
        Engine::vectorSceneManager[i] = nullptr;
      }
    }
    Engine::vectorSceneManager.resize(limit);
  }
}

int main() {
  logger.addLog(LogLevel::DEBUG, basePath, __func__, "logRica.txt");

  if (!gameStart())
    return 1;

  while (engine.getIsRunning() && !WindowShouldClose()) {
    engine.deltaTime = GetFrameTime();
    if (IsKeyPressed(KEY_ESCAPE))
      engine.setIsRunning(false);

    unsigned int currentSceneId = engine.sceneManager.getCurrentSceneID();
    if (currentSceneId >= Engine::vectorSceneManager.size() ||
      Engine::vectorSceneManager[currentSceneId] == nullptr) {
      logger.addLog(LogLevel::ERROR, basePath, "Invalid scene in main loop", "logRica.txt");
      logger.addLog(LogLevel::ERROR, basePath, "Invalid scene in main loop");

      break;
    }

    auto currentScenePtr = Engine::vectorSceneManager[currentSceneId];

    currentScenePtr->OnUpdate(GetFrameTime());

    BeginDrawing();
    ClearBackground(BLACK);
    if(engine.is3Dmode()){
      render3Dsystem.update(currentScenePtr->getAllEntities());
    }
    else{
      collider2DSystem.update(currentScenePtr->getAllEntities());
      render2Dsystem.update(currentScenePtr->getAllEntities());
      audioSystem.update(currentScenePtr->getAllEntities());
    }
    EndDrawing();

    logger.addLog(LogLevel::DEBUG, basePath, __func__,"logRica.txt");
    engine.update();
  }

  engine.shutdown();
  return 0;
}
</file>

</files>
